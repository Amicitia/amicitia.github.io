//------------------------------------------------
//--- 010 Editor v8.0 Binary Template
//
//      File: AtlusTable_P5.bt
//   Authors: TGE
//   Version: 1.0
//   Purpose: Parse Persona 5 Table files.
//  Category: Table
// File Mask: *.tbl
//  ID Bytes: 
//   History: 
//------------------------------------------------

//---------------------------------------------
// Includes
//---------------------------------------------
//#include "AtlusTable_P5_PersonaNames.bt"

//---------------------------------------------
// Type definition
//---------------------------------------------
typedef byte u8;
typedef ushort u16;
typedef uint u32;

typedef struct b08
{
    u8 bit0 : 1;
    u8 bit1 : 1;
    u8 bit2 : 1;
    u8 bit3 : 1;
    u8 bit4 : 1;
    u8 bit5 : 1;
    u8 bit6 : 1;
    u8 bit7 : 1;
};

typedef struct b16
{
    u8 bit0 : 1;
    u8 bit1 : 1;
    u8 bit2 : 1;
    u8 bit3 : 1;
    u8 bit4 : 1;
    u8 bit5 : 1;
    u8 bit6 : 1;
    u8 bit7 : 1;
    u8 bit8 : 1;
    u8 bit9 : 1;
    u8 bit10 : 1;
    u8 bit11 : 1;
    u8 bit12 : 1;
    u8 bit13 : 1;
    u8 bit14 : 1;
    u8 bit15 : 1;
};

typedef struct b32
{
    u8 bit0 : 1;
    u8 bit1 : 1;
    u8 bit2 : 1;
    u8 bit3 : 1;
    u8 bit4 : 1;
    u8 bit5 : 1;
    u8 bit6 : 1;
    u8 bit7 : 1;
    u8 bit8 : 1;
    u8 bit9 : 1;
    u8 bit10 : 1;
    u8 bit11 : 1;
    u8 bit12 : 1;
    u8 bit13 : 1;
    u8 bit14 : 1;
    u8 bit15 : 1;
    u8 bit16 : 1;
    u8 bit17 : 1;
    u8 bit18 : 1;
    u8 bit19 : 1;
    u8 bit20 : 1;
    u8 bit21 : 1;
    u8 bit22 : 1;
    u8 bit23 : 1;
    u8 bit24 : 1;
    u8 bit25 : 1;
    u8 bit26 : 1;
    u8 bit27 : 1;
    u8 bit28 : 1;
    u8 bit29 : 1;
    u8 bit30 : 1;
    u8 bit31 : 1;
};

//---------------------------------------------
// Helper functions
//---------------------------------------------
void AlignPosition( int alignment )
{
    local long position = FTell();
    local long alignedPosition = position + ( alignment - 1 ) & ~( alignment - 1 );
    FSeek( alignedPosition );
}

local uint __RandomSeed = 0xDEADBABE;
local uint __RandomBit = 0;
local uint __RandomCount = 0;
 
uint MyRandom( uint to )
{
    ++__RandomCount;
    __RandomBit  = ( (__RandomSeed >> 0 ) ^ ( __RandomSeed >> 2 ) ^ ( __RandomSeed >> 3 ) ^ ( __RandomSeed >> 5 ) ) & 1;
    __RandomSeed = ( ( ( ( __RandomBit << 15 ) | ( __RandomSeed >> 1 ) ) + ( 0xBABE / __RandomCount ) ) % to );

    while( __RandomSeed < 0 )
        __RandomSeed += to;

    return __RandomSeed;
}

//---------------------------------------------
// Define structures
//---------------------------------------------

// Persona
typedef struct PersonaStats
{
    b16 Flags1;
    u8 Arcana;
    u8 Level;
    u8 Strength;
    u8 Magic;
    u8 Endurance;
    u8 Agility;
    u8 Luck;
    u8 Unused;
    b16 Flags2;
    u16 Unknown;
};

typedef struct PersonaSkillSet
{
    u8 Strength;
    u8 Magic;
    u8 Endurance;
    u8 Agility;
    u8 Luck;
    u8 Unused;

    struct
    {        
        u8 PendingLevels;
        u8 Unknown; 
        u16 Skill;  
    } PersonaSkill[ 16 ];
};

typedef struct PersonaLevelUpThresholds
{
    u32 Thresholds[ 98 ];
};

// Elsai
typedef struct ElsaiSegment1Entry
{
    u16 Unused;
    u16 AiId; // All I know about this value is that if it's not 0, it causes the game to load an AI script for this enemy
    u32 Unknown[ 10 ];
};

typedef struct ElsaiSegment2Entry
{
    u8 Data[ 320 ];
};

// Encounter
typedef struct Encounter
{
    b32 Flags;
    u16 Field04;
    u16 Field06;
    u16 Units[ 5 ];
    u16 FieldId;
    u16 RoomId;
    u16 MusicId;
};

// Unit table
typedef struct UnitStats
{
    b16 Flags;
    u8 ArcanaId;
    u8 Unknown1[ 2 ];
    u8 Level;
    u8 Unknown2[ 2 ];
    u32 Hp;
    u32 Sp;
    u8 Strength;
    u8 Magic;
    u8 Endurance;
    u8 Agility;
    u8 Luck;
    u8 Unknown3;
    u16 SkillIds[ 8 ];
    u16 ExpReward;
    u16 MoneyReward;
    u16 Unknown4;
    u16 Unknown5;
    u8 Unknown6[ 18 ];
    b16 Unknown7;
    u16 AttackDamage;
};

typedef struct UnitVisualIndex
{
    u16 ShadowIndex;
    u16 ModelIndex;
};


//---------------------------------------------
// Parse file structure
//---------------------------------------------
enum TableSegmentType
{
    TableSegmentType_Unknown,
    TableSegmentType_Persona_Stats,
    TableSegmentType_Persona_SkillSets,
    TableSegmentType_Persona_LevelUpThresholds,
    TableSegmentType_Elsai_Segment1,
    TableSegmentType_Elsai_Segment2,
    TableSegmentType_Encounter,
    TableSegmentType_Unit_Stats,
    TableSegmentType_Unit_VisualIndex,
};

typedef struct TableSegment( TableSegmentType type )
{
    uint Size;

    switch ( type )
    {
        case TableSegmentType_Persona_Stats:
            PersonaStats Stats[ Size / sizeof( PersonaStats ) ];
            break;

        case TableSegmentType_Persona_SkillSets:
            PersonaSkillSet SkillSets[ Size / sizeof( PersonaSkillSet ) ];
            break;

        case TableSegmentType_Persona_LevelUpThresholds:
            PersonaLevelUpThresholds LevelUpThresholds[ Size / sizeof( PersonaLevelUpThresholds ) ];
            break;

        case TableSegmentType_Elsai_Segment1:
            ElsaiSegment1Entry Entries[ Size / sizeof( ElsaiSegment1Entry ) ];
            break;

        case TableSegmentType_Elsai_Segment2:
            ElsaiSegment2Entry Entries[ Size / sizeof( ElsaiSegment2Entry ) ];
            break;

        case TableSegmentType_Encounter:
            Encounter Encounters[ Size / sizeof( Encounter ) ];
            break;

        case TableSegmentType_Unit_Stats:
            UnitStats Stats[ Size / sizeof( UnitStats ) ];
            break;

        case TableSegmentType_Unit_VisualIndex:
            UnitVisualIndex VisualIndices[ Size / sizeof( UnitVisualIndex ) ];
            break;

        default:
            byte Data[ Size ];
    }
    
    AlignPosition( 16 );
};

// Test endianness
LittleEndian();
local uint sizeTest = ReadUInt( 0 );
if ( sizeTest & 0xFF000000 )
{
    BigEndian();
}

// Read table
local string filePath = GetFileName();
local string fileName = FileNameGetBase( filePath, false );
local int segmentIndex = 0;
local TableSegmentType segmentType;

struct
{
    while ( !FEof() )
    {
        segmentType = TableSegmentType_Unknown;
        if ( !Stricmp( fileName, "persona" ) )
        {
            switch ( segmentIndex )
            {
                case 0:
                    segmentType = TableSegmentType_Persona_Stats;
                    break;

                case 1:
                    segmentType = TableSegmentType_Persona_SkillSets;
                    break;

                case 2:
                    segmentType = TableSegmentType_Persona_LevelUpThresholds;
                    break;
            }
        }
        else if ( !Stricmp( fileName, "elsai" ) )
        {
            switch ( segmentIndex )
            {
                case 0:
                    segmentType = TableSegmentType_Elsai_Segment1;
                    break;

                case 1:
                    segmentType = TableSegmentType_Elsai_Segment2;
                    break;
            }
        } 
        else if ( !Stricmp( fileName, "encount" ) )
        {
            switch ( segmentIndex )
            {
                case 0:
                    segmentType = TableSegmentType_Encounter;
                    break;
            }
        }
        else if ( !Stricmp( fileName, "unit" ) )
        {
            switch ( segmentIndex )
            {
                case 0:
                    segmentType = TableSegmentType_Unit_Stats;
                    break;
                case 4:
                    segmentType = TableSegmentType_Unit_VisualIndex;
                    break;
            }
        }

        Printf( "%s\n", EnumToString( segmentType ) );
        SetBackColor( MyRandom( 0xFFFFFFFF ) );
        TableSegment Segment( segmentType );

        ++segmentIndex;
    }

} Table;